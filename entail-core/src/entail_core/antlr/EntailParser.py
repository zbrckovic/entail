# Generated from Entail.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3-")
        buf.write("\u00b0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\3\2\7\2.\n\2\f\2\16\2\61")
        buf.write("\13\2\3\2\7\2\64\n\2\f\2\16\2\67\13\2\3\2\3\2\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\7\4G\n\4\f\4")
        buf.write("\16\4J\13\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\6\6\6U\n")
        buf.write("\6\r\6\16\6V\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\5\bb")
        buf.write("\n\b\3\t\3\t\3\t\7\tg\n\t\f\t\16\tj\13\t\3\n\3\n\3\n\5")
        buf.write("\no\n\n\3\13\3\13\3\13\5\13t\n\13\3\f\3\f\5\fx\n\f\3\r")
        buf.write("\3\r\5\r|\n\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\20\3\20\3\20\3\21\3\21\3\22\3\22\5\22\u008f")
        buf.write("\n\22\3\23\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\25\3\25\5\25\u009d\n\25\3\26\6\26\u00a0\n\26\r\26\16")
        buf.write("\26\u00a1\3\26\3\26\3\26\3\26\7\26\u00a8\n\26\f\26\16")
        buf.write("\26\u00ab\13\26\3\26\5\26\u00ae\n\26\3\26\2\2\27\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*\2\5\3\2\21\"")
        buf.write("\3\2),\5\2\21\22!!##\2\u00ab\2/\3\2\2\2\4:\3\2\2\2\6@")
        buf.write("\3\2\2\2\bO\3\2\2\2\nT\3\2\2\2\fX\3\2\2\2\16_\3\2\2\2")
        buf.write("\20c\3\2\2\2\22n\3\2\2\2\24s\3\2\2\2\26w\3\2\2\2\30{\3")
        buf.write("\2\2\2\32}\3\2\2\2\34\u0081\3\2\2\2\36\u0087\3\2\2\2 ")
        buf.write("\u008a\3\2\2\2\"\u008e\3\2\2\2$\u0090\3\2\2\2&\u0095\3")
        buf.write("\2\2\2(\u009a\3\2\2\2*\u00ad\3\2\2\2,.\5\4\3\2-,\3\2\2")
        buf.write("\2.\61\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\65\3\2\2\2\61")
        buf.write("/\3\2\2\2\62\64\5\6\4\2\63\62\3\2\2\2\64\67\3\2\2\2\65")
        buf.write("\63\3\2\2\2\65\66\3\2\2\2\668\3\2\2\2\67\65\3\2\2\289")
        buf.write("\5\n\6\29\3\3\2\2\2:;\7\3\2\2;<\5\22\n\2<=\7\4\2\2=>\7")
        buf.write("\20\2\2>?\7\5\2\2?\5\3\2\2\2@A\7\6\2\2AB\5\22\n\2BC\7")
        buf.write("\7\2\2CH\5\b\5\2DE\7\b\2\2EG\5\b\5\2FD\3\2\2\2GJ\3\2\2")
        buf.write("\2HF\3\2\2\2HI\3\2\2\2IK\3\2\2\2JH\3\2\2\2KL\7\t\2\2L")
        buf.write("M\5\22\n\2MN\7\5\2\2N\7\3\2\2\2OP\5(\25\2PQ\7\n\2\2QR")
        buf.write("\5\22\n\2R\t\3\2\2\2SU\5\f\7\2TS\3\2\2\2UV\3\2\2\2VT\3")
        buf.write("\2\2\2VW\3\2\2\2W\13\3\2\2\2XY\7%\2\2YZ\7\13\2\2Z[\5\22")
        buf.write("\n\2[\\\7\f\2\2\\]\5\16\b\2]^\7\5\2\2^\r\3\2\2\2_a\t\2")
        buf.write("\2\2`b\5\20\t\2a`\3\2\2\2ab\3\2\2\2b\17\3\2\2\2ch\7%\2")
        buf.write("\2de\7\b\2\2eg\7%\2\2fd\3\2\2\2gj\3\2\2\2hf\3\2\2\2hi")
        buf.write("\3\2\2\2i\21\3\2\2\2jh\3\2\2\2ko\5\26\f\2lo\5\"\22\2m")
        buf.write("o\5(\25\2nk\3\2\2\2nl\3\2\2\2nm\3\2\2\2o\23\3\2\2\2pt")
        buf.write("\5\30\r\2qt\5\"\22\2rt\5(\25\2sp\3\2\2\2sq\3\2\2\2sr\3")
        buf.write("\2\2\2t\25\3\2\2\2ux\5\32\16\2vx\5\36\20\2wu\3\2\2\2w")
        buf.write("v\3\2\2\2x\27\3\2\2\2y|\5\34\17\2z|\5\36\20\2{y\3\2\2")
        buf.write("\2{z\3\2\2\2|\31\3\2\2\2}~\5\24\13\2~\177\5 \21\2\177")
        buf.write("\u0080\5\24\13\2\u0080\33\3\2\2\2\u0081\u0082\7\r\2\2")
        buf.write("\u0082\u0083\5\24\13\2\u0083\u0084\5 \21\2\u0084\u0085")
        buf.write("\5\24\13\2\u0085\u0086\7\13\2\2\u0086\35\3\2\2\2\u0087")
        buf.write("\u0088\7(\2\2\u0088\u0089\5\24\13\2\u0089\37\3\2\2\2\u008a")
        buf.write("\u008b\t\3\2\2\u008b!\3\2\2\2\u008c\u008f\5$\23\2\u008d")
        buf.write("\u008f\5&\24\2\u008e\u008c\3\2\2\2\u008e\u008d\3\2\2\2")
        buf.write("\u008f#\3\2\2\2\u0090\u0091\7\r\2\2\u0091\u0092\7$\2\2")
        buf.write("\u0092\u0093\7\13\2\2\u0093\u0094\5\24\13\2\u0094%\3\2")
        buf.write("\2\2\u0095\u0096\7\16\2\2\u0096\u0097\7$\2\2\u0097\u0098")
        buf.write("\7\17\2\2\u0098\u0099\5\24\13\2\u0099\'\3\2\2\2\u009a")
        buf.write("\u009c\t\4\2\2\u009b\u009d\5*\26\2\u009c\u009b\3\2\2\2")
        buf.write("\u009c\u009d\3\2\2\2\u009d)\3\2\2\2\u009e\u00a0\7$\2\2")
        buf.write("\u009f\u009e\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\u009f\3")
        buf.write("\2\2\2\u00a1\u00a2\3\2\2\2\u00a2\u00ae\3\2\2\2\u00a3\u00a4")
        buf.write("\7\r\2\2\u00a4\u00a9\7$\2\2\u00a5\u00a6\7\b\2\2\u00a6")
        buf.write("\u00a8\7$\2\2\u00a7\u00a5\3\2\2\2\u00a8\u00ab\3\2\2\2")
        buf.write("\u00a9\u00a7\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\u00ac\3")
        buf.write("\2\2\2\u00ab\u00a9\3\2\2\2\u00ac\u00ae\7\13\2\2\u00ad")
        buf.write("\u009f\3\2\2\2\u00ad\u00a3\3\2\2\2\u00ae+\3\2\2\2\21/")
        buf.write("\65HVahnsw{\u008e\u009c\u00a1\u00a9\u00ad")
        return buf.getvalue()


class EntailParser ( Parser ):

    grammarFileName = "Entail.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'import'", "'from'", "';'", "'in'", "'substitute'", 
                     "','", "'result'", "'with'", "')'", "':'", "'('", "'['", 
                     "']'", "<INVALID>", "'PR'", "'TH'", "'+A'", "'-A'", 
                     "'+E'", "'-E'", "'+IF'", "'-IF'", "'+IFF'", "'-IFF'", 
                     "'+AND'", "'-AND'", "'+OR'", "'-OR'", "'+NOT'", "'-NOT'", 
                     "'XP'", "'RP'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'~'", "'&'", "'|'", "'->'", 
                     "'<->'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "STRING", "RULE_PREMISE", 
                      "RULE_THEOREM", "RULE_A_IN", "RULE_A_OUT", "RULE_E_IN", 
                      "RULE_E_OUT", "RULE_IF_IN", "RULE_IF_OUT", "RULE_IFF_IN", 
                      "RULE_IFF_OUT", "RULE_AND_IN", "RULE_AND_OUT", "RULE_OR_IN", 
                      "RULE_OR_OUT", "RULE_NOT_IN", "RULE_NOT_OUT", "RULE_EXPLOSION", 
                      "RULE_REPETITION", "PRED_VAR", "IND_VAR", "NUMBER", 
                      "NEWLINE", "WS", "NEGATION", "CONJUNCTION", "DISJUNCTION", 
                      "CONDITIONAL", "BICONDITIONAL", "UNKNOWN" ]

    RULE_start = 0
    RULE_theoremImport = 1
    RULE_substitution = 2
    RULE_spec = 3
    RULE_deduction = 4
    RULE_line = 5
    RULE_ruleOfInference = 6
    RULE_ruleDependencies = 7
    RULE_rootFormula = 8
    RULE_formula = 9
    RULE_compRootFormula = 10
    RULE_compFormula = 11
    RULE_compRootBinaryFormula = 12
    RULE_compBinaryFormula = 13
    RULE_compUnaryFormula = 14
    RULE_binaryOperator = 15
    RULE_quantFormula = 16
    RULE_uniFormula = 17
    RULE_exiFormula = 18
    RULE_atomicFormula = 19
    RULE_terms = 20

    ruleNames =  [ "start", "theoremImport", "substitution", "spec", "deduction", 
                   "line", "ruleOfInference", "ruleDependencies", "rootFormula", 
                   "formula", "compRootFormula", "compFormula", "compRootBinaryFormula", 
                   "compBinaryFormula", "compUnaryFormula", "binaryOperator", 
                   "quantFormula", "uniFormula", "exiFormula", "atomicFormula", 
                   "terms" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    STRING=14
    RULE_PREMISE=15
    RULE_THEOREM=16
    RULE_A_IN=17
    RULE_A_OUT=18
    RULE_E_IN=19
    RULE_E_OUT=20
    RULE_IF_IN=21
    RULE_IF_OUT=22
    RULE_IFF_IN=23
    RULE_IFF_OUT=24
    RULE_AND_IN=25
    RULE_AND_OUT=26
    RULE_OR_IN=27
    RULE_OR_OUT=28
    RULE_NOT_IN=29
    RULE_NOT_OUT=30
    RULE_EXPLOSION=31
    RULE_REPETITION=32
    PRED_VAR=33
    IND_VAR=34
    NUMBER=35
    NEWLINE=36
    WS=37
    NEGATION=38
    CONJUNCTION=39
    DISJUNCTION=40
    CONDITIONAL=41
    BICONDITIONAL=42
    UNKNOWN=43

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._theoremImport = None # TheoremImportContext
            self.theoremImports = list() # of TheoremImportContexts
            self._substitution = None # SubstitutionContext
            self.substitutions = list() # of SubstitutionContexts

        def deduction(self):
            return self.getTypedRuleContext(EntailParser.DeductionContext,0)


        def theoremImport(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.TheoremImportContext)
            else:
                return self.getTypedRuleContext(EntailParser.TheoremImportContext,i)


        def substitution(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.SubstitutionContext)
            else:
                return self.getTypedRuleContext(EntailParser.SubstitutionContext,i)


        def getRuleIndex(self):
            return EntailParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = EntailParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==EntailParser.T__0:
                self.state = 42
                localctx._theoremImport = self.theoremImport()
                localctx.theoremImports.append(localctx._theoremImport)
                self.state = 47
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==EntailParser.T__3:
                self.state = 48
                localctx._substitution = self.substitution()
                localctx.substitutions.append(localctx._substitution)
                self.state = 53
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 54
            self.deduction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TheoremImportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.theorem = None # RootFormulaContext
            self.filepath = None # Token

        def rootFormula(self):
            return self.getTypedRuleContext(EntailParser.RootFormulaContext,0)


        def STRING(self):
            return self.getToken(EntailParser.STRING, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_theoremImport

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTheoremImport" ):
                listener.enterTheoremImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTheoremImport" ):
                listener.exitTheoremImport(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTheoremImport" ):
                return visitor.visitTheoremImport(self)
            else:
                return visitor.visitChildren(self)




    def theoremImport(self):

        localctx = EntailParser.TheoremImportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_theoremImport)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.match(EntailParser.T__0)
            self.state = 57
            localctx.theorem = self.rootFormula()
            self.state = 58
            self.match(EntailParser.T__1)
            self.state = 59
            localctx.filepath = self.match(EntailParser.STRING)
            self.state = 60
            self.match(EntailParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubstitutionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.theorem = None # RootFormulaContext
            self._spec = None # SpecContext
            self.specs = list() # of SpecContexts
            self.result = None # RootFormulaContext

        def rootFormula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.RootFormulaContext)
            else:
                return self.getTypedRuleContext(EntailParser.RootFormulaContext,i)


        def spec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.SpecContext)
            else:
                return self.getTypedRuleContext(EntailParser.SpecContext,i)


        def getRuleIndex(self):
            return EntailParser.RULE_substitution

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubstitution" ):
                listener.enterSubstitution(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubstitution" ):
                listener.exitSubstitution(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubstitution" ):
                return visitor.visitSubstitution(self)
            else:
                return visitor.visitChildren(self)




    def substitution(self):

        localctx = EntailParser.SubstitutionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_substitution)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(EntailParser.T__3)
            self.state = 63
            localctx.theorem = self.rootFormula()
            self.state = 64
            self.match(EntailParser.T__4)
            self.state = 65
            localctx._spec = self.spec()
            localctx.specs.append(localctx._spec)
            self.state = 70
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==EntailParser.T__5:
                self.state = 66
                self.match(EntailParser.T__5)
                self.state = 67
                localctx._spec = self.spec()
                localctx.specs.append(localctx._spec)
                self.state = 72
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 73
            self.match(EntailParser.T__6)
            self.state = 74
            localctx.result = self.rootFormula()
            self.state = 75
            self.match(EntailParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.substituted = None # AtomicFormulaContext
            self.substitute = None # RootFormulaContext

        def atomicFormula(self):
            return self.getTypedRuleContext(EntailParser.AtomicFormulaContext,0)


        def rootFormula(self):
            return self.getTypedRuleContext(EntailParser.RootFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpec" ):
                listener.enterSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpec" ):
                listener.exitSpec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpec" ):
                return visitor.visitSpec(self)
            else:
                return visitor.visitChildren(self)




    def spec(self):

        localctx = EntailParser.SpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            localctx.substituted = self.atomicFormula()
            self.state = 78
            self.match(EntailParser.T__7)
            self.state = 79
            localctx.substitute = self.rootFormula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeductionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._line = None # LineContext
            self.lines = list() # of LineContexts

        def line(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.LineContext)
            else:
                return self.getTypedRuleContext(EntailParser.LineContext,i)


        def getRuleIndex(self):
            return EntailParser.RULE_deduction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeduction" ):
                listener.enterDeduction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeduction" ):
                listener.exitDeduction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeduction" ):
                return visitor.visitDeduction(self)
            else:
                return visitor.visitChildren(self)




    def deduction(self):

        localctx = EntailParser.DeductionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_deduction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 81
                localctx._line = self.line()
                localctx.lines.append(localctx._line)
                self.state = 84 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==EntailParser.NUMBER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lineNumber = None # Token

        def rootFormula(self):
            return self.getTypedRuleContext(EntailParser.RootFormulaContext,0)


        def ruleOfInference(self):
            return self.getTypedRuleContext(EntailParser.RuleOfInferenceContext,0)


        def NUMBER(self):
            return self.getToken(EntailParser.NUMBER, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_line

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine" ):
                listener.enterLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine" ):
                listener.exitLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine" ):
                return visitor.visitLine(self)
            else:
                return visitor.visitChildren(self)




    def line(self):

        localctx = EntailParser.LineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_line)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            localctx.lineNumber = self.match(EntailParser.NUMBER)
            self.state = 87
            self.match(EntailParser.T__8)
            self.state = 88
            self.rootFormula()
            self.state = 89
            self.match(EntailParser.T__9)
            self.state = 90
            self.ruleOfInference()
            self.state = 91
            self.match(EntailParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleOfInferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ruleName = None # Token

        def RULE_PREMISE(self):
            return self.getToken(EntailParser.RULE_PREMISE, 0)

        def RULE_THEOREM(self):
            return self.getToken(EntailParser.RULE_THEOREM, 0)

        def RULE_A_IN(self):
            return self.getToken(EntailParser.RULE_A_IN, 0)

        def RULE_A_OUT(self):
            return self.getToken(EntailParser.RULE_A_OUT, 0)

        def RULE_E_IN(self):
            return self.getToken(EntailParser.RULE_E_IN, 0)

        def RULE_E_OUT(self):
            return self.getToken(EntailParser.RULE_E_OUT, 0)

        def RULE_IF_IN(self):
            return self.getToken(EntailParser.RULE_IF_IN, 0)

        def RULE_IF_OUT(self):
            return self.getToken(EntailParser.RULE_IF_OUT, 0)

        def RULE_IFF_IN(self):
            return self.getToken(EntailParser.RULE_IFF_IN, 0)

        def RULE_IFF_OUT(self):
            return self.getToken(EntailParser.RULE_IFF_OUT, 0)

        def RULE_AND_IN(self):
            return self.getToken(EntailParser.RULE_AND_IN, 0)

        def RULE_AND_OUT(self):
            return self.getToken(EntailParser.RULE_AND_OUT, 0)

        def RULE_OR_IN(self):
            return self.getToken(EntailParser.RULE_OR_IN, 0)

        def RULE_OR_OUT(self):
            return self.getToken(EntailParser.RULE_OR_OUT, 0)

        def RULE_NOT_IN(self):
            return self.getToken(EntailParser.RULE_NOT_IN, 0)

        def RULE_NOT_OUT(self):
            return self.getToken(EntailParser.RULE_NOT_OUT, 0)

        def RULE_EXPLOSION(self):
            return self.getToken(EntailParser.RULE_EXPLOSION, 0)

        def RULE_REPETITION(self):
            return self.getToken(EntailParser.RULE_REPETITION, 0)

        def ruleDependencies(self):
            return self.getTypedRuleContext(EntailParser.RuleDependenciesContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_ruleOfInference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleOfInference" ):
                listener.enterRuleOfInference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleOfInference" ):
                listener.exitRuleOfInference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleOfInference" ):
                return visitor.visitRuleOfInference(self)
            else:
                return visitor.visitChildren(self)




    def ruleOfInference(self):

        localctx = EntailParser.RuleOfInferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ruleOfInference)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            localctx.ruleName = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << EntailParser.RULE_PREMISE) | (1 << EntailParser.RULE_THEOREM) | (1 << EntailParser.RULE_A_IN) | (1 << EntailParser.RULE_A_OUT) | (1 << EntailParser.RULE_E_IN) | (1 << EntailParser.RULE_E_OUT) | (1 << EntailParser.RULE_IF_IN) | (1 << EntailParser.RULE_IF_OUT) | (1 << EntailParser.RULE_IFF_IN) | (1 << EntailParser.RULE_IFF_OUT) | (1 << EntailParser.RULE_AND_IN) | (1 << EntailParser.RULE_AND_OUT) | (1 << EntailParser.RULE_OR_IN) | (1 << EntailParser.RULE_OR_OUT) | (1 << EntailParser.RULE_NOT_IN) | (1 << EntailParser.RULE_NOT_OUT) | (1 << EntailParser.RULE_EXPLOSION) | (1 << EntailParser.RULE_REPETITION))) != 0)):
                localctx.ruleName = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==EntailParser.NUMBER:
                self.state = 94
                self.ruleDependencies()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleDependenciesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._NUMBER = None # Token
            self.lineNumbers = list() # of Tokens

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(EntailParser.NUMBER)
            else:
                return self.getToken(EntailParser.NUMBER, i)

        def getRuleIndex(self):
            return EntailParser.RULE_ruleDependencies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleDependencies" ):
                listener.enterRuleDependencies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleDependencies" ):
                listener.exitRuleDependencies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleDependencies" ):
                return visitor.visitRuleDependencies(self)
            else:
                return visitor.visitChildren(self)




    def ruleDependencies(self):

        localctx = EntailParser.RuleDependenciesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ruleDependencies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            localctx._NUMBER = self.match(EntailParser.NUMBER)
            localctx.lineNumbers.append(localctx._NUMBER)
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==EntailParser.T__5:
                self.state = 98
                self.match(EntailParser.T__5)
                self.state = 99
                localctx._NUMBER = self.match(EntailParser.NUMBER)
                localctx.lineNumbers.append(localctx._NUMBER)
                self.state = 104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RootFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compRootFormula(self):
            return self.getTypedRuleContext(EntailParser.CompRootFormulaContext,0)


        def quantFormula(self):
            return self.getTypedRuleContext(EntailParser.QuantFormulaContext,0)


        def atomicFormula(self):
            return self.getTypedRuleContext(EntailParser.AtomicFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_rootFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRootFormula" ):
                listener.enterRootFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRootFormula" ):
                listener.exitRootFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRootFormula" ):
                return visitor.visitRootFormula(self)
            else:
                return visitor.visitChildren(self)




    def rootFormula(self):

        localctx = EntailParser.RootFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_rootFormula)
        try:
            self.state = 108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.compRootFormula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.quantFormula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 107
                self.atomicFormula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compFormula(self):
            return self.getTypedRuleContext(EntailParser.CompFormulaContext,0)


        def quantFormula(self):
            return self.getTypedRuleContext(EntailParser.QuantFormulaContext,0)


        def atomicFormula(self):
            return self.getTypedRuleContext(EntailParser.AtomicFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula" ):
                listener.enterFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula" ):
                listener.exitFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula" ):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)




    def formula(self):

        localctx = EntailParser.FormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_formula)
        try:
            self.state = 113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.compFormula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.quantFormula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 112
                self.atomicFormula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompRootFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compRootBinaryFormula(self):
            return self.getTypedRuleContext(EntailParser.CompRootBinaryFormulaContext,0)


        def compUnaryFormula(self):
            return self.getTypedRuleContext(EntailParser.CompUnaryFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_compRootFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompRootFormula" ):
                listener.enterCompRootFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompRootFormula" ):
                listener.exitCompRootFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompRootFormula" ):
                return visitor.visitCompRootFormula(self)
            else:
                return visitor.visitChildren(self)




    def compRootFormula(self):

        localctx = EntailParser.CompRootFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_compRootFormula)
        try:
            self.state = 117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.compRootBinaryFormula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.compUnaryFormula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compBinaryFormula(self):
            return self.getTypedRuleContext(EntailParser.CompBinaryFormulaContext,0)


        def compUnaryFormula(self):
            return self.getTypedRuleContext(EntailParser.CompUnaryFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_compFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompFormula" ):
                listener.enterCompFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompFormula" ):
                listener.exitCompFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompFormula" ):
                return visitor.visitCompFormula(self)
            else:
                return visitor.visitChildren(self)




    def compFormula(self):

        localctx = EntailParser.CompFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_compFormula)
        try:
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [EntailParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.compBinaryFormula()
                pass
            elif token in [EntailParser.NEGATION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.compUnaryFormula()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompRootBinaryFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lFormula = None # FormulaContext
            self.rFormula = None # FormulaContext

        def binaryOperator(self):
            return self.getTypedRuleContext(EntailParser.BinaryOperatorContext,0)


        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.FormulaContext)
            else:
                return self.getTypedRuleContext(EntailParser.FormulaContext,i)


        def getRuleIndex(self):
            return EntailParser.RULE_compRootBinaryFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompRootBinaryFormula" ):
                listener.enterCompRootBinaryFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompRootBinaryFormula" ):
                listener.exitCompRootBinaryFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompRootBinaryFormula" ):
                return visitor.visitCompRootBinaryFormula(self)
            else:
                return visitor.visitChildren(self)




    def compRootBinaryFormula(self):

        localctx = EntailParser.CompRootBinaryFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_compRootBinaryFormula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            localctx.lFormula = self.formula()
            self.state = 124
            self.binaryOperator()
            self.state = 125
            localctx.rFormula = self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompBinaryFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lParen = None # Token
            self.lFormula = None # FormulaContext
            self.rFormula = None # FormulaContext
            self.rParen = None # Token

        def binaryOperator(self):
            return self.getTypedRuleContext(EntailParser.BinaryOperatorContext,0)


        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EntailParser.FormulaContext)
            else:
                return self.getTypedRuleContext(EntailParser.FormulaContext,i)


        def getRuleIndex(self):
            return EntailParser.RULE_compBinaryFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompBinaryFormula" ):
                listener.enterCompBinaryFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompBinaryFormula" ):
                listener.exitCompBinaryFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompBinaryFormula" ):
                return visitor.visitCompBinaryFormula(self)
            else:
                return visitor.visitChildren(self)




    def compBinaryFormula(self):

        localctx = EntailParser.CompBinaryFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_compBinaryFormula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            localctx.lParen = self.match(EntailParser.T__10)
            self.state = 128
            localctx.lFormula = self.formula()
            self.state = 129
            self.binaryOperator()
            self.state = 130
            localctx.rFormula = self.formula()
            self.state = 131
            localctx.rParen = self.match(EntailParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompUnaryFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None # Token

        def formula(self):
            return self.getTypedRuleContext(EntailParser.FormulaContext,0)


        def NEGATION(self):
            return self.getToken(EntailParser.NEGATION, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_compUnaryFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompUnaryFormula" ):
                listener.enterCompUnaryFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompUnaryFormula" ):
                listener.exitCompUnaryFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompUnaryFormula" ):
                return visitor.visitCompUnaryFormula(self)
            else:
                return visitor.visitChildren(self)




    def compUnaryFormula(self):

        localctx = EntailParser.CompUnaryFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_compUnaryFormula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            localctx.operator = self.match(EntailParser.NEGATION)
            self.state = 134
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None # Token

        def CONDITIONAL(self):
            return self.getToken(EntailParser.CONDITIONAL, 0)

        def DISJUNCTION(self):
            return self.getToken(EntailParser.DISJUNCTION, 0)

        def CONJUNCTION(self):
            return self.getToken(EntailParser.CONJUNCTION, 0)

        def BICONDITIONAL(self):
            return self.getToken(EntailParser.BICONDITIONAL, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_binaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryOperator" ):
                listener.enterBinaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryOperator" ):
                listener.exitBinaryOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryOperator" ):
                return visitor.visitBinaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryOperator(self):

        localctx = EntailParser.BinaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_binaryOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            localctx.operator = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << EntailParser.CONJUNCTION) | (1 << EntailParser.DISJUNCTION) | (1 << EntailParser.CONDITIONAL) | (1 << EntailParser.BICONDITIONAL))) != 0)):
                localctx.operator = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uniFormula(self):
            return self.getTypedRuleContext(EntailParser.UniFormulaContext,0)


        def exiFormula(self):
            return self.getTypedRuleContext(EntailParser.ExiFormulaContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_quantFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantFormula" ):
                listener.enterQuantFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantFormula" ):
                listener.exitQuantFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantFormula" ):
                return visitor.visitQuantFormula(self)
            else:
                return visitor.visitChildren(self)




    def quantFormula(self):

        localctx = EntailParser.QuantFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_quantFormula)
        try:
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [EntailParser.T__10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 138
                self.uniFormula()
                pass
            elif token in [EntailParser.T__11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 139
                self.exiFormula()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lParen = None # Token
            self.indVar = None # Token
            self.rParen = None # Token

        def formula(self):
            return self.getTypedRuleContext(EntailParser.FormulaContext,0)


        def IND_VAR(self):
            return self.getToken(EntailParser.IND_VAR, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_uniFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniFormula" ):
                listener.enterUniFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniFormula" ):
                listener.exitUniFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniFormula" ):
                return visitor.visitUniFormula(self)
            else:
                return visitor.visitChildren(self)




    def uniFormula(self):

        localctx = EntailParser.UniFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_uniFormula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            localctx.lParen = self.match(EntailParser.T__10)
            self.state = 143
            localctx.indVar = self.match(EntailParser.IND_VAR)
            self.state = 144
            localctx.rParen = self.match(EntailParser.T__8)
            self.state = 145
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExiFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lBracket = None # Token
            self.indVar = None # Token
            self.rBracket = None # Token

        def formula(self):
            return self.getTypedRuleContext(EntailParser.FormulaContext,0)


        def IND_VAR(self):
            return self.getToken(EntailParser.IND_VAR, 0)

        def getRuleIndex(self):
            return EntailParser.RULE_exiFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExiFormula" ):
                listener.enterExiFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExiFormula" ):
                listener.exitExiFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExiFormula" ):
                return visitor.visitExiFormula(self)
            else:
                return visitor.visitChildren(self)




    def exiFormula(self):

        localctx = EntailParser.ExiFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_exiFormula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            localctx.lBracket = self.match(EntailParser.T__11)
            self.state = 148
            localctx.indVar = self.match(EntailParser.IND_VAR)
            self.state = 149
            localctx.rBracket = self.match(EntailParser.T__12)
            self.state = 150
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomicFormulaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.predVar = None # Token

        def RULE_PREMISE(self):
            return self.getToken(EntailParser.RULE_PREMISE, 0)

        def RULE_THEOREM(self):
            return self.getToken(EntailParser.RULE_THEOREM, 0)

        def RULE_EXPLOSION(self):
            return self.getToken(EntailParser.RULE_EXPLOSION, 0)

        def PRED_VAR(self):
            return self.getToken(EntailParser.PRED_VAR, 0)

        def terms(self):
            return self.getTypedRuleContext(EntailParser.TermsContext,0)


        def getRuleIndex(self):
            return EntailParser.RULE_atomicFormula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomicFormula" ):
                listener.enterAtomicFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomicFormula" ):
                listener.exitAtomicFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomicFormula" ):
                return visitor.visitAtomicFormula(self)
            else:
                return visitor.visitChildren(self)




    def atomicFormula(self):

        localctx = EntailParser.AtomicFormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_atomicFormula)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            localctx.predVar = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << EntailParser.RULE_PREMISE) | (1 << EntailParser.RULE_THEOREM) | (1 << EntailParser.RULE_EXPLOSION) | (1 << EntailParser.PRED_VAR))) != 0)):
                localctx.predVar = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==EntailParser.T__10 or _la==EntailParser.IND_VAR:
                self.state = 153
                self.terms()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IND_VAR = None # Token
            self.indVars = list() # of Tokens
            self.lParen = None # Token
            self.rParen = None # Token

        def IND_VAR(self, i:int=None):
            if i is None:
                return self.getTokens(EntailParser.IND_VAR)
            else:
                return self.getToken(EntailParser.IND_VAR, i)

        def getRuleIndex(self):
            return EntailParser.RULE_terms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerms" ):
                listener.enterTerms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerms" ):
                listener.exitTerms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerms" ):
                return visitor.visitTerms(self)
            else:
                return visitor.visitChildren(self)




    def terms(self):

        localctx = EntailParser.TermsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_terms)
        self._la = 0 # Token type
        try:
            self.state = 171
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [EntailParser.IND_VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 157 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 156
                    localctx._IND_VAR = self.match(EntailParser.IND_VAR)
                    localctx.indVars.append(localctx._IND_VAR)
                    self.state = 159 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==EntailParser.IND_VAR):
                        break

                pass
            elif token in [EntailParser.T__10]:
                self.enterOuterAlt(localctx, 2)
                self.state = 161
                localctx.lParen = self.match(EntailParser.T__10)
                self.state = 162
                localctx._IND_VAR = self.match(EntailParser.IND_VAR)
                localctx.indVars.append(localctx._IND_VAR)
                self.state = 167
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==EntailParser.T__5:
                    self.state = 163
                    self.match(EntailParser.T__5)
                    self.state = 164
                    localctx._IND_VAR = self.match(EntailParser.IND_VAR)
                    localctx.indVars.append(localctx._IND_VAR)
                    self.state = 169
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 170
                localctx.rParen = self.match(EntailParser.T__8)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





